package nez.generator;

import nez.lang.And;
import nez.lang.AnyChar;
import nez.lang.ByteChar;
import nez.lang.ByteMap;
import nez.lang.Capture;
import nez.lang.Choice;
import nez.lang.Empty;
import nez.lang.Expression;
import nez.lang.Failure;
import nez.lang.Grammar;
import nez.lang.Link;
import nez.lang.New;
import nez.lang.NonTerminal;
import nez.lang.Not;
import nez.lang.Option;
import nez.lang.Production;
import nez.lang.Repetition;
import nez.lang.Repetition1;
import nez.lang.Replace;
import nez.lang.Sequence;
import nez.lang.Tagging;
import nez.util.StringUtils;

public class PEGTLGenerator extends GrammarGenerator {

	PEGTLGenerator() {
		super(null);
	}

	PEGTLGenerator(String fileName) {
		super(fileName);
	}

	@Override
	public String getDesc() {
		return "Parsing Expression Grammar Template Library for C++11";
	}

	public void makeHeader(Grammar g) {
		L("// The following is generated by the Nez Grammar Generator ");
		L("include<pegtl.hh>");
		
		for(Production p: g.getProductionList()) {
			L("struct " + _NonTerminal(p) + ";");
		}

		
	}
	
	public void makeFooter(Grammar g) {
		
	}
	protected String _NonTerminal(Production p) {
		return "p" + p.getLocalName().replace("~", "_").replace("!", "NOT").replace(".", "DOT");
	}

	protected String _Open() { return "<"; };
	protected String _Close() { return ">"; };
	protected String _Delim() { return ","; };

	@Override
	public void visitProduction(Production p) {
		Expression e = p.getExpression();
		L("struct " + _NonTerminal(p) + " : ");
		inc();
		L("");
		visit(e);
		W(" {};");
		dec();
	}	

	public void visitEmpty(Empty e) {
		C("pegtl::success");
	}

	public void visitFailure(Failure e) {
		C("pegtl::failure");
	}

	public void visitNonTerminal(NonTerminal e) {
		W(_NonTerminal(e.getProduction()));
	}
	
	public void visitByteChar(ByteChar e) {
		C("pegtl::one", e.byteChar);
	}

	public void visitByteMap(ByteMap e) {
		C("pegtl::one", e.byteMap);
	}

	public void visitString(String s) {
		int cnt = 0;
		W("pegtl::string").W(_Open());
		for(int c = 0; c < s.length(); c++) {
			if(cnt>0) {
				W(_Delim());
			}
			W(String.valueOf((int)s.charAt(c)));
			cnt++;
		}
		W(_Close());
	}

	public void visitAnyChar(AnyChar e) {
		W("pegtl::any");
	}

	public void visitOption(Option e) {
		C("pegtl::opt", e);
	}
	
	public void visitRepetition(Repetition e) {
		C("pegtl::star", e);
	}
	
	public void visitRepetition1(Repetition1 e) {
		C("pegtl::plus", e);
	}

	public void visitAnd(And e) {
		C("pegtl::at", e);
	}
	
	public void visitNot(Not e) {
		C("pegtl::not_at", e);
	}
	
	public void visitChoice(Choice e) {
		C("pegtl::sor", e);
	}
	
	public void visitSequence(Sequence e) {
		W("pegtl::seq<");
		super.visitSequence(e);
		W(">");
	}
	
	public void visitNew(New e) {
		W("pegtl::success");
//		if(e.lefted) {
//			C("LCapture", e.shift);
//		}
//		else {
//			C("NCapture", e.shift);
//		}
	}

	public void visitCapture(Capture e) {
		W("pegtl::success");
//		C("Capture", e.shift);
	}

	public void visitTagging(Tagging e) {
		W("pegtl::success");
//		C("Tagging", e.getTagName());
	}
	
	public void visitReplace(Replace e) {
		W("pegtl::success");
//		C("Replace", StringUtils.quoteString('"', e.value, '"'));
	}
	
	public void visitLink(Link e) {
//		if(e.index != -1) {
//			C("Link", String.valueOf(e.index), e);
//		}
//		else {
//			C("Link", e);
//		}
		visit(e.get(0));
	}

	@Override
	public void visitUndefined(Expression e) {
		if(e.size() > 0) {
			visit(e.get(0));
		}
		else {
			W("pegtl::success");
		}
//		W("<");
//		W(e.getPredicate());
//		for(Expression se : e) {
//			W(" ");
//			visit(se);
//		}
//		W(">");
	}

}
